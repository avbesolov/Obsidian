#вопросы_с_собесов #git
#### Чем отличается git pull от git fetch?  
Грубо говоря, по дефолту git pull — это шоткод для последовательности двух команд: git fetch (получение изменений с сервера) и git merge (сливание в локальную копию).
#### Отличие git merge от git rebase  
Согласно официальному руководству **Git** **rebase** “повторно применяет коммиты поверх другой базовой ветки”, тогда как **merge** “объединяет две или более историй разработки”. Иначе говоря, основное **отличие** между ними в том, что **слияние** сохраняет историю в первозданном виде, а перебазирование ее перезаписывает.

**git merge  -** собрать воедино разветвленную историю

**git rebase**  - В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую.
#### Откат на предыдущий коммит
1. Временно переключиться на другой коммит  
`git checkout aaaaaa`  
2. Переключиться на коммит и продолжить работу с него  
`git checkout -b имя-новой-ветки aaaaaa`  
3. Удалить изменения в рабочей области и вернуть ее к состоянию как при последнем коммите.  
`git stash save --keep-index  
`git reset --hard HEAD`  
#### Как исправить git-conflict

Чтобы устранить конфликт слияния в Git, необходимо вручную отредактировать конфликтующий файл и выбрать изменения, которые нужно сохранить в окончательном слиянии.

Существует несколько способов устранения конфликта слияния:

1.      Если конфликт слияния вызван конкурирующими изменениями строк, например, при внесении разных изменений в одну строку одного файла в разных ветвях в репозитории Git, его можно разрешить на GitHub с помощью редактора конфликтов.

2.      Для остальных типов конфликтов слияния необходимо разрешить конфликт слияния в локальном клоне репозитория и отправить изменение в ветвь на GitHub. Для отправки изменений можно использовать командную строку или средство, например, GitHub Desktop.  
#### Тэги и ветки
В Git есть несколько типов ссылок:

1.      **Ветки (Branches)** — это ссылки, которые могут перемещаться. Они обычно используются для разработки новых функций или исправления ошибок в отдельной ветке, которая затем может быть объединена с основной веткой.

2.      **Теги (Tags)** — это неизменяемые ссылки, которые обычно применяются для обозначения определённых версий (релизов) проекта. В отличие от веток, теги не перемещаются, они всегда указывают на один и тот же коммит.
#### git cherry-pick  
это полезная команда, с помощью которой можно выборочно применить коммиты Git к текущей рабочей ветке HEAD. С ее помощью можно выбрать коммит из одной ветки и применить его к другой.

Команда git cherry-pick — это удобный способ отменить изменения. Например, если коммит попал в ветку по ошибке, вы можете переключиться на нужную ветку и выполнить перенос.
#### Как закидывать пароли на Git-репозиторий?  
Инициализируем репозиторий git-secret (будет создан каталог .gitsecret/):
   `git secret init`

Добавляем пользователя (name@pgp_email - связанный с RSA-ключами email):
   `git secret tell name@pgp_email`

Помечаем секретные файлы  (после данной операции git_secret не позволит
поместить их в репозиторий без шифрования):
   `git secret add имена_файлов`

Шифруем ранее помеченные файлы:
   `git secret hide`

Шифрование производится при помощи открытого ключа, ранее переданного командой `git secret tell`. Произвольное число разработчиков могут зашифровать файлы, но только владелец закрытого ключа может их расшифровать.

Теперь можно выполнять коммит. Чтобы не запускать команду `git secret hide`
перед каждым коммитом, её рекомендуется прописать для автоматического вызова на стадии pre-commit.

Для расшифровки файлов необходимо выполнить команду:
   `git secret reveal`
#### Можно ли вернуть несохраненные файлы после git checkout . или git reset --hard?
Нет.  

Как предотвратить чтобы такое с вами больше не случилось, отменяйте изменения безопасным способом:
`git stash save`

Эта команда отменяет все изменения в рабочей области и в индексе (относительно 
HEAD), сохраняя их в stash. Потом его можно использовать либо удалить.
# использовать - `git stash apply`
# удалить- `git stash drop`

*Как восстановить?*
Для начала, проверьте историю и временные файлы своего текстового редактора или среды разработки. Многие из них делают собственные бэкапы по ходу работы на случай непредвиденных обстоятельств.Если измененная версия файлов сначала была добавлена (проиндексирована, `git add`), то так:
`git fsck --lost-found`
Каждый найденный объект будет выложен в папку `.git/lost-found/other/` в том же виде, в каком и был (т.е. не blob), но с sha1 соответствующего blob'a вместо имени. Таким образом, содержимое файлов восстановить можно, имена - нельзя.

Если файлы не были даже проиндексированы и `git checkout`, то средствами Git никак не восстановить.
