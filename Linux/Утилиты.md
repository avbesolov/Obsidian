#вопросы_с_собесов #linux 

#### top (значения)
В команде **top** в Linux есть информация об использовании CPU.

Вот некоторые значения, которые она показывает:

**us** — потребление CPU пользовательскими процессами;
**sy** — потребление CPU системными процессами;
**ni** — потребление CPU пользовательскими процессами с изменённым приоритетом (командой nice или renice);
**id** — простаивание CPU (от idle — работать вхолостую);
**wa** — процент времени, в течение которого процессор простаивал, ожидая завершения операции ввода-вывода;
**hi** — процент времени работы аппаратных прерываний;
**si** — процент времени работы программных прерываний;
**st** — процент времени, когда реальный процессор не был доступен виртуальной машине.  
#### lsof
Утилита `lsof` - это невероятно полезная команда, которая выводит список всех открытых файлов (LiSts all Open Files).

Утилита `lsof` по умолчанию выводит следующую информацию о каждом файле:

- `COMMAND` — название процесса или команды, которая использует файл;
- `PID` — идентификатор процесса;
- `USER` — пользователь, которому принадлежит процесс;
- `FD` — дескриптор файла (например, `cwd` — текущий рабочий каталог, `txt` — исполняемый код, `mem` — отображенные в память файлов, `rtd` — корневой каталог);
- `TYPE` — тип файла или объекта файловой системы (например, `REG` — обычный файл, `DIR` — каталог, и другие);
- `DEVICE` — мажорный и минорный номера устройства, на котором находится файл;
- `SIZE/OFF` — размер файла или значение смещения в нем;
- `NODE` — номер индексного дескриптора (`inode`);
- `NAME` — абсолютный путь к файлу.

`lsof -u user` - отображение файлов, используемых конкретным пользователем
`lsof -u ^user` - исключить файлы опред. пользователя
`lsof -i` - Поиск процессов, которые прослушивают сетевые порты
`lsof -i -u user` - информация о файлах, открытых процессами конкретного пользователя, использующих сетевые соединения
`lsof -i TCP:22` - Просмотр процессов, работающих на сетевых портах определенного диапазона
`lsof -p 1` - Вывод списка файлов, используемых определенным процессом
`lsof -t -u user` - вывести на экран идентификаторы процессов запущенных конкретным пользователем
`kill -9 $(lsof -t -u user)` - завершить процессы конкретного пользователя

https://blog.sedicomm.com/2020/03/19/10-primerov-komand-lsof-v-linux/ - 10 примеров использования команды lsof в Linux
https://reference-xi.vercel.app/lsof.html - lsof cheatsheet
#### mount
[https://losst.pro/montirovanie-diska-v-linux](https://losst.pro/montirovanie-diska-v-linux)_  
добавление диска (устройства) в автозагрузки системы  
`sudo fdisk -l`  
Ищем наш раздел, запоминаем его название. Например, /dev/sda2.  
Теперь создаем директорию /mnt/D.  
`sudo mkdir -p /mnt/D`  
Затем редактируем файл /etc/fstab, чтобы диск монтировался при загрузке.  
Добавляем строчку:  
`/dev/sda2        /mnt/D        ntfs-3g        ro        1 1`  
Где:  
/dev/sda2 - монтируемый раздел  
/mnt/D - точка монтирования  
ntfs-3g - файловая система  
ro - для монтирования в режиме только для чтения. Если нужно писать на раздел, замени на defaults  
Теперь при загрузке ОС раздел /dev/sda2 будет монтироваться в /mnt/D.
#### fstab
Fstab (сокр. от англ. file systems table) — один из конфигурационных файлов в UNIX-подобных системах, который содержит информацию о различных файловых системах и устройствах хранения информации компьютера.

Он описывает, как диск (раздел) будет использоваться или как будет интегрирован в систему.

Полный путь к файлу — /etc/fstab.
#### fdisk
[https://losst.pro/komanda-fdisk-v-linux](https://losst.pro/komanda-fdisk-v-linux)  
Команда fdisk (format disk, форматировать диск) — это наиболее распространенная утилита командной строки для работы с дисками в Linux. Позволяет просматривать, создавать, удалять, изменять, копировать и перемещать разделы на жестком диске, используя простой интерфейс текстовых меню.
#### lvm (Logical Volume Manager)
это очень мощная система управления томами с данными для Linux. Она позволяет создавать поверх физических разделов (или даже неразбитых винчестеров) логические тома, которые в самой системе будут видны как обычные блочные устройства с данными (т.е. как обычные разделы).  
[https://help.ubuntu.ru/wiki/lvm](https://help.ubuntu.ru/wiki/lvm)  
#### systemd
это **программный пакет, который предоставляет множество системных компонентов для операционных систем Linux**. Основная цель - унифицировать конфигурацию и поведение сервиса во всех дистрибутивах Linux. Его основным компонентом является "system and service manager" – система инициализации, используемая для начальной загрузки пользовательского пространства и управления пользовательскими процессами.

Подсистема инициализации и управления службами в Linux[https://habr.com/ru/companies/slurm/articles/255845/](https://habr.com/ru/companies/slurm/articles/255845/)

Вот некоторые основные команды systemd:
1. **systemctl start name.service** — запуск сервиса.
2. **systemctl stop name.service** — остановка сервиса.
3. **systemctl restart name.service** — перезапуск сервиса.
4. **systemctl try-restart name.service** — перезапуск сервиса только, если он запущен.
5. **systemctl reload name.service** — перезагрузка конфигурации сервиса.
6. **systemctl status name.service** — проверка, запущен ли сервис с детальным выводом состояния сервиса.
7. **systemctl is-active name.service** — проверка, запущен ли сервис с простым ответом: active или inactive.
8. **systemctl list-units --type service --all** — отображение статуса всех сервисов.
9. **systemctl enable name.service** — активирует сервис (позволяет стартовать во время запуска системы).
10. **systemctl disable name.service** — деактивирует сервис.
#### rpm - менеджер пакетов
(рекурсивный акроним RPM Package Manager — RPM — менеджер пакетов) — **формат пакетов программного обеспечения, а также программа, созданная для управления этими пакетами, используемые в ряде Linux-дистрибутивов.** Является основным форматом пакетов в LSB.

Изначально разработанный компанией Red Hat для Red Hat Linux, RPM стал использоваться во многих дистрибутивах Linux и был портирован на другие операционные системы: Novell NetWare (с версии 6.5 SP3), IBM AIX (с версии 5) и прочие.

https://churchill.ddns.me.uk/post/rpm-cheat-sheet/ - cheatsheet
#### yum - менеджер пакетов
(Yellowdog Updater, Modified) — открытый консольный менеджер пакетов для дистрибутивов Linux, основанных на пакетах формата RPM** (RedHat, CentOS, Fedora, Oracle Linux).

Он позволяет облегчить работу с обновлениями дистрибутивов, отслеживая взаимозависимости между пакетами.

**Возможности YUM:**

- поиск пакетов в репозиториях;
- установка пакетов из репозиториев;
- установка пакетов из .rpm-файлов с удовлетворением зависимостей с помощью репозиториев;
- обновление системы;
- удаление ненужных пакетов;
- даунрейд пакетов.

https://habr.com/ru/articles/301292/ - шпаргалка
#### cron
утилита для планирования задач в операционной системе Linux. Она позволяет запускать скрипты или команды автоматически в определенное время, с определенной периодичностью или при определенных событиях.

https://devhints.io/cron - cron cheatsheet
#### logrotate
это системная утилита, которая управляет автоматической ротацией и сжатием лог-файлов. Если в процессе длительной работы сервера файлы не были ротированы, сжаты и периодически не удалялись, то рано или поздно они могут занять весь доступный объем памяти.

https://losst.pro/nastrojka-logrotate - Настройка Logrotate
https://www.jamescoyle.net/cheat-sheets/676-logrotate-cheat-sheet - logrotate cheatsheet
#### iptables 
это инструмент командной строки, который используется для настройки и управления брандмауэром ядра Linux.

Он позволяет создавать правила, которые определяют, как обрабатывается входящий и исходящий трафик. Его можно использовать для блокировки или разрешения трафика на основе IP-адреса, номера порта, протокола и других критериев.

https://www.youtube.com/watch?v=wHUYOX_pUek&t=2094s - полезный видос
https://andreafortuna.org/2019/05/08/iptables-a-simple-cheatsheet/ - iptables cheatsheet
#### ss 
консольная **утилита**, которая предоставляет информацию о сетевых сокетах, подключениях TCP/UDP, маршрутизации и других сетевых статистических данных. 
**ss** отображает информацию аналогично **утилите** netstat и при этом выводит больше информации о сетевых соединениях и их состоянии, чем какие-либо другие инструменты

*Пример использования*
`ss -tulpn`
- -t: Показывает только TCP-соединения.
- -u: Показывает только UDP-соединения.
- -l: Показывает только слушающие порты.
- -p: Показывает идентификаторы процессов (PID), связанные с сокетами.
- -n: Показывает числовой формат IP-адресов и портов вместо их имен.

https://www.golinuxcloud.com/ss-command-in-linux/ - cheatsheet
#### atop
это продвинутый интерактивный полноэкранный монитор производительности.
Он является аналогом top, но в отличие от него выводит только новые изменения об активных системных процессах.
Важной особенностью является возможность сохранения данных в файл собственного двоичного формата.

**Основные параметры**
- Строка **PRC** – отображает общие данные на уровне процессов и потоков:
    - sys, user – общее время процессора, затраченное в системном режиме и в пользовательском режиме соответственно; 
    - proc – общее количество процессов, активных в системе на текущий момент;
    - trun – общее количество потоков, активных в данный момент;
    - tslpi – общее количество потоков, которые сейчас находятся в спящем режиме и могут быть прерваны;
    - tslpu – общее количество потоков, которые в текущее время находятся в спящем режиме и не могут быть прерваны;
    - zombie – количество процессов-зомби;
    - clones – количество системных вызовов клонов для процессов;
    - exit – количество процессов, завершившихся за прошедшее время.
- Строка **CPU** – выводит общие данные о нагрузке на центральный процессор. Верхняя строка показывает общую занятость для всего процессора. В случае многоядерной системы для каждого отдельного ядра отображается дополнительные строки с «cpu» в нижнем регистре, отсортированные по активности. Для каждого ядра и всего процессора содержатся следующие показатели:
    - sys, user – общее время процессора, затраченное в системном режиме и в пользовательском режиме соответственно;
    - irq – процент времени процессора, затраченного на обработку прерываний;
    - idle – процент неиспользованного времени процессора, когда ни один из процессов не ожидает дискового ввода-вывода;
    - wait – процент неиспользованного времени процессора, пока по крайней мере один процесс ждал дисковый ввод-вывод;
- Строка **CPL** – показывает  LA (Load Average) за 1, 5 и 15 минут, а также количество доступных ядер процессора.
- Строка **MEM** – показывает общую информацию об оперативной памяти:
    - tot – общий объем доступной оперативной памяти;
    - free – общий объем свободной памяти;
    - cache – текущий объем кэш-памяти;
    - dirty – объем памяти в страничном кэше, который необходимо сбросить на диск;
    - buff  – объем памяти, используемый для метаданных файловой системы;
- Строка **Swap** – показывает общую информацию о swap.
- Строка **DSK** — показывает использование диска:
    - busy – процент времени, в течение которого система занята обработкой запросов;
    - read – выданные запросы на чтение;
    - write – выданные запросы на запись;
    - KiB/r и KiB/w – скорость чтения и записи данных (в КB) на каждый запрос;
    - MBr/s и MBw/s – временные показатели для чтения и записи на диск в мегабайтах.
    - avio – среднее количество миллисекунд, затраченных на обработку запросов.
- Строки **NET** – показывают общую статистику использованию сети на транспортном и сетевом уровне, а также отдельно по каждому активному сетевому интерфейсу.
  
-----

**Во время работы программы можно применять следующие горячие клавиши для изменения нижней части окна:**

- **для изменения отображения таблицы процессов — отвечает за просмотр:**

        'm' - памяти, используемой процессами;
        'd'  - использования диска процессами;
        'n'  - использования сети;
        'v'  - детальной информации по  процессам (ppid, user/group, date/time, status, exitcode)
        'c'  - полной команды для каждого процесса.

- **для сортировки по использованию:**

        'C'  - процессора;
        'M' - оперативной памяти;
        'D'  - оперативной дисковой системы;
        'N'  - оперативной дисковой сети;
        'A'  -  самые активные пользователи ресурсов (auto mode).

- **для суммирования:**

        'u'  - по пользователям системы;
        'p'  - по процессам.

 - **для поиска* — фокус на определённом:**

        'U'  - пользователе системы;
        'P'  - процессе по названию;
        'I'  - процессе по PID;
        '/'  - выражении командной строки или её части.
        
-----

**Общий вывод команды `atop` отображает следующие сведения для каждой записи процесса:**

- PID – идентификатор процесса.
- SYSCPU — объем ЦП, потребляемый процессом при работе системы.
- USRCPU – количество ЦП, потребляемое процессом во время его работы в пользовательском режиме.
- VGROW – объем виртуальной памяти, которую процесс занял с момента последнего обновления значения.
- RGROW — объем резидентной (физической) памяти, увеличенный с момента последнего обновления значения.
- RDDSK — размер данных, передаваемых во время чтения с диска.
- WRDSK — размер данных, передаваемых во время записи на диск.
- RUID – реальный идентификатор пользователя, под которым выполняется процесс.
- EUID — эффективный идентификатор пользователя, под которым выполняется процесс.
- ST – текущий статус процесса.
- EXC – код выхода после завершения процесса.
- THR — количество потоков в процессе.
- S – текущий статус основного потока процесса.
- ЦП – процент использования ЦП для всего процесса.
- CMD — имя процесса.

**Потребление памяти**
`atop -m`

- PID – идентификатор процесса.
- TID – идентификатор потока.
- MINFLT – количество незначительных ошибок страниц, которые были устранены путем доступа к данным с бесплатных страниц.
- MAJFLT – количество серьезных ошибок страниц, которые были устранены путем извлечения данных с диска.
- VSTEXT — виртуальная память, занятая текстом процесса.
- VSLIBS – виртуальная память, занимаемая общими библиотеками процесса.
- VDATA — размер виртуальной памяти для частных данных процесса.
- VSTACK — размер виртуальной памяти частного стека процесса.
- VSIZE — общий размер виртуальной памяти процесса.
- RSIZE — общая резидентная память, занятая процессом.
- MEM — процент оперативной памяти, потребляемой процессом.

**Использование диска**
`atop -d`

В выводе, специфичном для диска, не так много вещей, на которые можно обратить внимание. Вот некоторые из ключевых выводов:

- RDDSK — размер данных, передаваемых во время чтения с диска.
- WRDSK — размер данных, передаваемых во время записи на диск.
- WCANCL — размер данных, изначально записанных, но позже удаленных.
- DSK – процент занятого места на диске.
- CMD — имя процесса.

**Еще команды**
`atop -c` - просмотреть процессы работающие в фоновом режиме
`atop -y` - информация по потокам
`atop -v` - подробнее о процессе
`atop -au` - количество процессов для каждого пользователя в системе
`atop -s` - на каком ядре работает процесс

https://firstvds.ru/technology/statistika-nagruzki-na-server-atop - работа с atop
#### atopsar
Команда atopsar — это встроенный анализатор логов atop, который позволит быстро найти проблему и смотреть лог в нужное вам время.

**Общая структура команды:**
`atopsar [-flags] [-r file|date|y...] [-R cnt] [-b hh:mm] [-e hh:mm]`

Все логи сохраняются в каталоге по пути **/var/log/atop/**, файлы именуются по формату `atop_<дата>`.

Основные ключи:

- **-r** — считывание данных из файла;
- **-b** — с какого времени вывести лог;
- **-e** — до какого времени вывести лог.

Дополнительные опции для анализа:

- **-d** — нагрузка на каждый диск;
- **-m** — нагрузка на оперативную память и **swap**;
- **-с** — нагрузка на процессор, отдельно по каждому ядру;
- **-p** — количество процессов и потоков;
- **-w** — нагрузка на сетевой трафик;
- **-i** — нагрузка на интерфейс;
- **-O** — топ-3 процессов по использованию процессора;
- **-G** — топ-3 процессов по использованию памяти;
- **-D** — топ-3 процессов по использованию диска;
- **-N** — топ-3 процессов по использованию сети;
- **-A** — все возможные отчеты.

Например, можно смотреть нагрузку на диск по анализу логов за определенный день и время, используя ключ **-d**:  

`atopsar -r /var/log/atop/atop_20231130 -d -b 14:00 -e 16:00`

https://redos.red-soft.ru/base/manual/utilites/atopsar/ - работа с atopsar
#### ncdu
Утилита `ncdu` — один из самых удобных инструментов для анализа дискового пространства. Она имеет псевдографический интерфейс, что значительно упрощает работу с ней.

`ncdu имя_каталога` - просканировать и вывести данные о конкретной директории:

**Формат вывода**

Количество символов `#` помогает определить, какие файлы и каталоги занимают больше всего места.

Крайний левый столбец может содержать дополнительные обозначения:

- `!` — ошибка при чтении каталога;
- `.` — ошибка при чтении подкаталога, т.е. указанный размер может быть некорректным;
- `<` — объект исключен из подсчета (с помощью опции `--exclude`);
- `>` — объект из другой файловой системы;
- `@` — объект не является файлом или каталогом (символическая ссылка, сокет);
- `H` — объект уже был учтен (жесткая ссылка);
- `e` — пустой каталог.
  
**Доступные функции интерфейса**

С помощью следующих клавиш можно управлять полученным выводом:

- `n` — упорядочить элементы по имени (в прямом и обратном порядке);
- `s` — упорядочить элементы по размеру (в прямом и обратном порядке);
- `g` — переключение между отображением «графика» (####) и объёма в процентах;
- `a` — переключение между отображением реального размера файлов и объемом занимаемого пространства на диске;
- `e` — скрыть/показать скрытые файлы и папки;
- `?` — вызвать краткую справку;
- `d` — удалить выбранный элемент (перед удалением будет запрошено подтверждение действия);
- `i` — вывести информацию о выбранном элементе
- `q` — выйти.

https://timeweb.cloud/docs/unix-guides/troubleshooting-unix/disk-space-analysis-ncdu-du 
#### du
утилита позволяет получить общую информацию о занятом месте

При выполнении команды она выводит объем пространства, занимаемого каждым файлом и каталогом в текущем каталоге:

`du -shc /*` - выведет итоговый размер указанной директории в человекочитаемом виде с общим размером занятого пространства

`du -sch ./* | sort -hr` - Полезный и удобный способ подсчета и сортировки

https://timeweb.cloud/docs/unix-guides/troubleshooting-unix/disk-space-analysis-ncdu-du 

#### ssh-keygen

***Генерация нового SSH ключа***
`ssh-keygen -t ed25519 -f Название_ключа -C "your_email@example.com"`

Для большей защиты рекомендую [сгенерировать](https://privacycanada.net/strong-password-generator/) passphrase 

| ssh-keygen               | команда для генерации SSH ключа                                                                                         |
| ------------------------ | ----------------------------------------------------------------------------------------------------------------------- |
| -t ed25519               | алгоритм шифрования, по умолчанию алгоритм rsa, Github рекомендует использовать алгоритм ed25519                        |
| -f                       | название ключа (опционально)                                                                                            |
| -C                       | значит "комментарий", все что после этой команды в кавычках будет комментарием (опционально)                            |
| "your_email@example.com" | комментарий, замените на свой email в Github - это нужно чтобы различать SSH ключи между собой, их может быть несколько |
https://best-manual.ru/blog/diy/2022-11-21-nastrojka-dostupa-po-ssh-klyuchu-v-github-v-windows-i-macos.html - полезная статья

***Добавление SSH ключа в SSH-agent***

> **Не пропускай этот шаг! Без него ничего работать не будет.**

ssh-agent — это менеджер ключей для SSH. Он хранит ваши ключи и сертификаты в памяти, незашифрованные и готовые к использованию ssh . Это избавляет вас от необходимости вводить пароль каждый раз, когда вы подключаетесь к серверу.

1. Сначала запустим SSH-agent командой ниже:  
	`eval "$(ssh-agent -s)"`  
	надпись **Agent pid 61** (у вас будет любое другое число) говорит о том, что агент успешно запущен!

2. Добавьте SSH ключ в SSH агент командой ниже, предварительно поменяв название SSH ключа на ваше:  
	`ssh-add ~/.ssh/название_ключа`

3. Добавим конфигурационный файл, чтобы SSH ключ автоматически добавлялся в SSH-agent, введите команду ниже, она создаст файл **config**, если он отсутствует:  
    `touch ~/.ssh/config`

4. Теперь в созданный файл config добавим следующий текст, заменив id_ed25519_github на название своего ключа, если нужно:
	`Host *` 
		`AddKeysToAgent yes`
		 `IdentityFile ~/.ssh/название_ключа`
