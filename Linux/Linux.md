#вопросы_с_собесов #linux #bash

#### Устройство файловой системы Linux  
**Файловая система Linux представляет собой иерархическую структуру каталогов и файлов (в виде дерева).

В Linux файловая система представлена единым корневым каталогом, обозначаемым как слэш (/). Соответственно, при данной файловой структуре не диски содержат каталоги, а каталог — диски.

Основные директории в Linux:

/bin — двоичные исполняемые файлы;
/boot — файлы, используемые для загрузки системы;
/dev — файлы устройств (драйверов);
/etc — файлы конфигураций программ;
/home — домашние каталоги учетных записей пользователей;
/lib — системные библиотеки;
/lost+found — файлы, восстановленные после сбоя работы системы;
/media — точка монтирования внешних носителей;
/mnt — точка временного монтирования.

Назначение каждой директории регламентирует «Стандарт иерархии файловой системы» FHS (Filesystem Hierarchy Standard).  
  
[https://gist.github.com/rmnssnvsk/981a2aef08fc008e08bd](https://gist.github.com/rmnssnvsk/981a2aef08fc008e08bd)
#### Директория /proc  
/proc — это директория, к которой примонтирована виртуальная файловая система procfs. Различная информация, которую ядро может сообщить пользователям, находится в "файлах" каталога /proc. Например, в файле /proc/modules находится список загруженных модулей ядра. А в файле /proc/cpuinfo — информация о процессоре компьютера. Подробнее можно прочитать здесь.  
#### Директория /sys  
/sys — это **директория**, к которой примонтирована виртуальная файловая система sysfs, которая добавляет в пространство пользователя информацию ядра Linux о присутствующих в системе устройствах и драйверах.  
#### Состояния процессов:  
**Каждый запущенный процесс в Linux может находиться в одном из следующих состояний:

1.      **Активен (R=Running)** — процесс находится в очереди на выполнение, то есть либо выполняется в данный момент, либо ожидает выделения ему очередного кванта времени центрального процессора.
2.      **«Спит» (S=Sleeping)** — процесс находится в состоянии прерываемого ожидания, то есть ожидает какого-то события, сигнала или освобождения нужного ресурса.
3.      **Находится в состоянии непрерываемого ожидания (D=Direct)** — процесс ожидает определенного («прямого») сигнала от аппаратной части и не реагирует на другие сигналы.
4.      **Приостановлен (T)** — процесс находится в режиме трассировки (обычно такое состояние возникает при отладке программ).
5.    **«Зомби» (Z=Zombie)** — это процесс, выполнение которого завершилось, но относящиеся к нему структуры ядра по каким-то причинам не освобождены.  
#### Основные команды linux  
cd, df -h, mv, cp и тд
#### Как удалить большое количество файлов
`find . -delete или find /mnt/test_dir/ -type f -delete`

`cd /mnt/test_dir/ ; ls -f . | xargs -n 100 rm`  
параметр -f говорит, что не нужно сортировать список файлов

[https://habr.com/ru/articles/157613/](https://habr.com/ru/articles/157613/) 
#### top (значения)
В команде **top** в Linux есть информация об использовании CPU.

Вот некоторые значения, которые она показывает:

**us** — потребление CPU пользовательскими процессами;
**sy** — потребление CPU системными процессами;
**ni** — потребление CPU пользовательскими процессами с изменённым приоритетом (командой nice или renice);
**id** — простаивание CPU (от idle — работать вхолостую);
**wa** — процент времени, в течение которого процессор простаивал, ожидая завершения операции ввода-вывода;
**hi** — процент времени работы аппаратных прерываний;
**si** — процент времени работы программных прерываний;
**st** — процент времени, когда реальный процессор не был доступен виртуальной машине.  
#### Зомби-процессы
это мертвые и несуществующие процессы, которые занимают место в таблице системных процессов (остатки закрытого программного обеспечения.)  
Такие процессы могут вызвать проблемы.  
#### chown & chmod  
**[https://habr.com/ru/articles/109392/](https://habr.com/ru/articles/109392/)
#### Как** **починить** **chmod -x /bin/chmod?**  
`Python> import os
Python> os.chmod("/bin/chmod",0755)  `
#### Что такое Load Average?  
**Load** **Average** - среднее значение загрузки системы за некоторый период времени, как правило, отображается в виде трёх значений, которые представляют собой усредненные величины за последние 1, 5 и 15 минут, **чем ниже значение, тем ниже нагрузка на сервер**. В UNIX это среднее значение вычислительной работы, которую выполняет система. (uptime, top, htop)  
Под средней нагрузкой на сервер понимают суммарную нагрузку процессами на центральный процессор и подсистему ввода/вывода за определённый промежуток времени.  
Максимальным пределом для Load Average обычно считается количество ядер на сервере, которые способны обрабатывать процессы.  
1, 5, 15 - Если первое число больше чем второе и третье, значит нагрузка в данный момент растёт. Если третье число самое большое, второе поменьше, а первое ещё меньше — значит нагрузка на сервере была высокой, но уже упала.  
#### SWAP
один из механизмов виртуальной памяти, при котором отдельные фрагменты памяти (обычно неактивные) перемещаются из ОЗУ во вторичное хранилище (отдельный раздел или файл), освобождая ОЗУ для загрузки других активных фрагментов памяти.

#### Inode
это **структура данных в которой хранится информация о файле или директории в файловой системе**. В файловой системе Linux, например Ext4, у файла есть не только само его содержимое, например, тот текст, но и метаданные, такие как имя, дата создания, доступа, модификации и права. Вот эти метаданные и хранятся в Inode. У каждого файла есть своя уникальная Inode и именно здесь указано в каких блоках находятся данные файла.
#### Типы файловых систем Linux
Список основных файловых систем: **Ext2; Ext3; Ext4; JFS; ReiserFS; XFS; Btrfs; ZFS**. ФС может являться корневой в различных разделах, Linux позволяет использовать разные системы одновременно. Ext2, Ext3, Ext4. Первая группа ФС — Extended Filesystem (Ext2, Ext3, Ext4) — является стандартом для Linux. Как следствие, это самые распространенные системы. Они редко обновляются, но зато стабильны.  
#### Какой сигнал отправится демону/сервису при выполнении команды «systemctl stop daemon_name»?  
Сигнал на остановку службы  
#### Какая команда на GNU/Linux поможет найти файлы, которые менялись в последние полчаса? 
`find . -mmin -30`  
#### Добавить пользователя в группу:  
`sudo groupadd docker` – создать группу “docker”  
`sudo usermod -aG docker $USER` – добавить в группу пользователя (ubuntu)  
#### Как просмотреть открытые приложением файловые дескрипторы?  
В Linux всё является файлами

lsof означает ‘LiSt Open Files’ (список открытых файлов). Эта программа используется чтобы узнать, какие файлы открыты и каким процессом.
#### Дескриптор файла
это целое число без знака, с помощью которого процесс обращается к открытому файлу. stdin, stdout, stderr (0, 1, 2)
#### Аутентификация и авторизация  
Простыми словами, аутентификация — это процесс, подтверждающий вашу личность, а авторизация — это процесс, определяющий ваши права после того, как ваша личность подтверждена.  
  
Пример из реальной жизни: когда показываете паспорт на границе, это аутентификация, вы подтверждаете, что вы — Вася Петров. А можно ли вам выезжать из страны? Это уже решает авторизация.  
  
В Linux за аутентификацию отвечают файлы, такие как /etc/passwd (хранит информацию о пользователях) и /etc/shadow (хранит зашифрованные пароли пользователей).  
  
Процесс авторизации наступает после аутентификации и определяет, к каким ресурсам или действиям у вас есть доступ. Разрешено ли вам иметь доступ к определенным разделам сервиса?

Здесь Linux определяет какие у вас есть права доступа с помощью информации из файлов /etc/group — там описаны группы и их члены, и /etc/sudoers — там описано кто может исполнять команды с правами суперпользователя.  
  
Помните: аутентификация всегда предшествует авторизации. Сначала система должна узнать, кто вы, а затем решить, что вы можете делать.  
#### Протоколы аутентификации, авторизации  
Протокол аутентификации — это тип **протокола** компьютерной связи или криптографического **протокола**, специально предназначенного для передачи аутентификационных данных между двумя объектами.  
#### Как заменить в файле строчки другими строчками?  
`sed -i 's/original/new/g' file.txt`  
#### Как распарсить какой-нибудь access.log в Nginx средствами BASH?  
`sudo cat /var/log/nginx/access.log | awk '{ print $1}' | sort | uniq -c | sort` - список IP-адресов пользователей и их количество
#### Симлинк (symlink)  
Символическая ссылка (также «симлинк», от англ. Symbolic link) — специальный файл в файловой системе, в котором вместо пользовательских данных содержится путь к файлу, открываемому при обращении к данной ссылке.**Ln** **— команда Unix, создающая жёсткую ссылку или символьную ссылку на файл.**

Формат команды:

`ln файл имя_ссылки` — создаётся «жёсткая» ссылка (hard link);
`ln -s файл имя_ссылки` — создаётся «символьная» ссылка (symbolic link).

Эта команда создаёт жёсткую ссылку на файл «файл1», которая будет выглядеть и располагаться как «файл2». Таким образом для файловой системы заданный файл «файл1» и ссылка на него «файл2» физически будут являться одним и тем же файлом.

Жёсткая ссылка не может указывать на файл, расположенный на другом дисковом разделе. Также невозможно создать жёсткую ссылку на каталог.
#### Как работает оперативная память компьютера и для чего она нужна
В оперативной памяти в системе Linux хранятся:

- данные ядра;
- данные процессов;
- файлы, которые были прочитаны с жесткого диска или записаны на него.

За выделение оперативной памяти отвечает ядро Linux.

Оперативная память разбивается на страницы по 4KB, а при определённых настройках можно выделить большие страницы (2MB), которые называются HugePages.

Также оперативная память в Linux разбивается на зоны:

— DMA,  
— DMA32,  
— Normal.

Работа с файлами на диске также идёт через оперативную память. Для этого выделяются Cache и Buffer.  
#### Подсистема ввода-вывода  
В Linux ввод и вывод распределяются между тремя стандартными потоками:

- **stdin** — стандартный ввод (клавиатура).
- **stdout** — стандартный вывод (экран).
- **stderr** — стандартная ошибка (вывод ошибок на экран).

Потоки пронумерованы:

- stdin — 0,
- stdout — 1,
- stderr — 2.

Из стандартного ввода команда может только считывать данные, а два других потока могут использоваться только для записи.  
#### Как извлечь данные из лога за определённый период?
`sed -n '/Feb 23 13:55/,/Feb 23 14:00/p' /var/log/mail.log` (пример)  
#### Как в access-логе Nginx посмотреть самые активные IP-адреса за последние сутки с помощью BASH?
[https://jeka.by/post/1067/grep-all-ips/](https://jeka.by/post/1067/grep-all-ips/)  
`less /var/log/nginx/access.log | cut -d' ' -f1 | sort | uniq -c`
#### mount
[https://losst.pro/montirovanie-diska-v-linux](https://losst.pro/montirovanie-diska-v-linux)_  
добавление диска (устройства) в автозагрузки системы  
`sudo fdisk -l`  
Ищем наш раздел, запоминаем его название. Например, /dev/sda2.  
Теперь создаем директорию /mnt/D.  
`sudo mkdir -p /mnt/D`  
Затем редактируем файл /etc/fstab, чтобы диск монтировался при загрузке.  
Добавляем строчку:  
`/dev/sda2        /mnt/D        ntfs-3g        ro        1 1`  
Где:  
/dev/sda2 - монтируемый раздел  
/mnt/D - точка монтирования  
ntfs-3g - файловая система  
ro - для монтирования в режиме только для чтения. Если нужно писать на раздел, замени на defaults  
Теперь при загрузке ОС раздел /dev/sda2 будет монтироваться в /mnt/D.  
#### fstab
Fstab (сокр. от англ. file systems table) — один из конфигурационных файлов в UNIX-подобных системах, который содержит информацию о различных файловых системах и устройствах хранения информации компьютера.

Он описывает, как диск (раздел) будет использоваться или как будет интегрирован в систему.

Полный путь к файлу — /etc/fstab.
#### fdisk
[https://losst.pro/komanda-fdisk-v-linux](https://losst.pro/komanda-fdisk-v-linux)  
Команда fdisk (format disk, форматировать диск) — это наиболее распространенная утилита командной строки для работы с дисками в Linux. Позволяет просматривать, создавать, удалять, изменять, копировать и перемещать разделы на жестком диске, используя простой интерфейс текстовых меню.
#### Bash скриптинг

`#!/bin/bash`

`our comment is here`
`echo "The current directory is:"`
`pwd`
`echo "The user logged in is:"`
`whoami`

[https://habr.com/ru/companies/ruvds/articles/325522/](https://habr.com/ru/companies/ruvds/articles/325522/)
#### Что такое буферная и кэш-память в Linux

В более широком смысле, **буфер** – это область памяти, которая временно хранит данные в пути, т.е. данные, которые перемещаются из одной точки в другую. Он содержит метаданные, которые помогают повысить производительность записи.

С другой стороны, **кэш** – это область временного хранения, в которой хранятся часто используемые данные для более быстрого доступа. Когда данные хранятся в кэше, доступ к ним в последующих случаях становится намного быстрее, так как данные извлекаются из кэшированной копии, а не из оригинала.  
#### Очистка системных данных в Linux
- Очистка дискового кэша в Linux  
  `sync; echo 1 > /proc/sys/vm/drop_caches`  
  
- Очистка Dentries & Inodes
  `sync; echo 2 > /proc/sys/vm/drop_caches'`  
  
- Очистка Pagecache, Dentries & Inodes  
  `sync; echo 3 > /proc/sys/vm/drop_caches`  
  
Все вышеприведенные команды разделены на две части с помощью точки с запятой ( ; ), которая появляется между командами sync и echo.

Опция sync очищает буфер файловой системы, а команда echo записывает данные в drop_cache и таким образом очищает кэш, не убивая ни одного приложения/сервиса.

Затем вернемся к запятой, которая инструктирует оболочку выполнить первую команду и после ее выполнения выполнить следующую. Таким образом, в данном случае сначала выполняется команда sync, а затем команда echo.  
#### Как очистить файл подкачки в Linux?

Подкачка swap – это область на жестком диске, которая используется, когда память RAM почти исчерпана или исчерпана. В некоторых ситуациях вам может потребоваться очистить пространство подкачки на вашем компьютере Linux.

Чтобы очистить файл подкачки, просто выполните следующую команду от имени root

`swapoff -a && swapon -a ` 
[https://itshaman.ru/news/linux/kak-opustoshit-bufernuyu-i-kesh-pamyat-v-linux](https://itshaman.ru/news/linux/kak-opustoshit-bufernuyu-i-kesh-pamyat-v-linux)
#### Logical Volume Manager (LVM)
это очень мощная система управления томами с данными для Linux. Она позволяет создавать поверх физических разделов (или даже неразбитых винчестеров) логические тома, которые в самой системе будут видны как обычные блочные устройства с данными (т.е. как обычные разделы).  
[https://help.ubuntu.ru/wiki/lvm](https://help.ubuntu.ru/wiki/lvm)  
#### Как сделать так, чтобы команда всегда выполнялась при старте новой сессии bash?
Добавить ее в файл bashrc  
#### Сравнение чисел (bash)
![[сравнение_чисел.png]]  
#### Сравнение строк (bash)  
![[сравнение_строк.png]]
операторы > и < необходимо экранировать  
Пример if [ $val1 \> $val2 ]  
#### Проверка файлов
![[проверка_файлов.png]]
#### Systemd
Подсистема инициализации и управления службами в Linux[https://habr.com/ru/companies/slurm/articles/255845/](https://habr.com/ru/companies/slurm/articles/255845/)
#### Жизненный цикл ПО

- Сбор и анализ требований
- Планирование (Проектирование)
- Разработка
- Тестирование
- Деплой (Развертывание)
- Эксплуатация
#### Типы namespaces в linux  
В Linux существует **семь типов пространств имён (namespaces)**:

1.      Cgroups.
2.      IPC.
3.      Network.
4.      Mount.
5.      PID.
6.      User.
7.      UTS.

Например, **Network namespace** включает в себя системные ресурсы, связанные с сетью, такие как сетевые интерфейсы (например, wlan0, eth0), таблицы маршрутизации и т.д. **Mount namespace** включает файлы и каталоги в системе. **PID namespace** содержит ID процессов и так далее.

Пространства имён (namespaces) предоставляются самим ядром Linux и являются необходимостью для запуска любого процесса в системе.
#### Что будет, если выполнить в консоли из-под root’a chmod a-x $(which chmod) и как это починить?  
- `rsync --chmod=777  
- `python2 -c "import os; os.chmod('/bin/chmod', 0755)" ` 
- `python3 -c "import os; os.chmod('/bin/chmod', 0o755)"`  `
- Стандартная утилита cp умеет перекладывать не только сами файлики, но и переносить отдельно их атрибуты:
	`cp --attributes-only --preserve=mode /bin/chown /bin/chmod  `
- Скопировать с другого сервера

Наверняка, кто-то скажет (и это самый популярный почему-то вариант): скопировать с другой системы. И это можно сделать двумя способами:

- с помощью утилиты scp с флагом -p;
- с помощью утилиты rsync с флагами -av
#### /dev/null
это специальное устройство (файл устройства) в Unix-подобных операционных системах, предназначенное для обнуления данных. Когда данные отправляются в /dev/null, они фактически игнорируются и уничтожаются, а не сохраняются или выводятся куда-либо.

Этот файл устройства часто используется для отбрасывания ненужного вывода программ или для обнуления содержимого файлов, как мы обсуждали ранее. Все данные, направленные в /dev/null, просто исчезают, не занимая никакого места на диске.

/dev/null - это очень полезный инструмент, который позволяет программам выводить данные, но не сохранять их, или создавать файлы с нулевым содержимым, освобождая место на диске.  
#### Использование /dev/null  
1. **Отбрасывание вывода**: Если тебе не нужен вывод какой-либо команды или программы, направь его в /dev/null. Например:

   `ls > /dev/null`

   Это перенаправит вывод команды ls в /dev/null и он просто исчезнет.

2. **Игнорирование сообщений об ошибках**: Если тебе нужно исполнить команду, но ты не хочешь видеть сообщения об ошибках, можно перенаправить stderr в /dev/null:

   `command 2> /dev/null`

3. **Создание пустых файлов**: Можно использовать /dev/null для создания файлов с нулевым содержимым:

   `cat /dev/null > empty_file.txt`

4. **Очистка содержимого файла**: Если тебе нужно обнулить содержимое файла, можно перенаправить /dev/null в этот файл:

   `cat /dev/null > file_to_empty.txt`

Однако помни, что /dev/null уничтожает данные без возможности их восстановления, поэтому будь осторожен при его использовании!
#### Зануление файла с помощью /dev/null  

1. **Зануление файла:**
   Для зануления содержимого файла можно использовать команду cat /dev/null > файл, где файл - это путь к файлу, который нужно занулить.

   Например:
   `cat /dev/null > example.txt`

   Эта команда просто перенаправляет нулевой вывод /dev/null в выбранный файл, что приводит к занулению его содержимого.

2. **Скопировать /dev/null в файл:**
   Также можно скопировать содержимое /dev/null в желаемый файл, используя команду cp /dev/null файл.

   Например:
   `cp /dev/null example.txt`