#вопросы_с_собесов #linux #bash
#### Узнать версию дистрибутива Linux
Если интересует только информация о дистрибутиве без лишних подробностей, то лучше воспользоваться командой: `cat /etc/issue` после введения которой на экране появится информация о версии.

Если нужны более детальные сведения — введите команду:` lsb_release -a` Она выведет название, версию и кодовое имя дистрибутива.
#### Устройство файловой системы Linux  
**Файловая система Linux представляет собой иерархическую структуру каталогов и файлов (в виде дерева).

В Linux файловая система представлена единым корневым каталогом, обозначаемым как слэш (/). Соответственно, при данной файловой структуре не диски содержат каталоги, а каталог — диски.

Основные директории в Linux:

/bin — двоичные исполняемые файлы;
/boot — файлы, используемые для загрузки системы;
/dev — файлы устройств (драйверов);
/etc — файлы конфигураций программ;
/home — домашние каталоги учетных записей пользователей;
/lib — системные библиотеки;
/lost+found — файлы, восстановленные после сбоя работы системы;
/media — точка монтирования внешних носителей;
/mnt — точка временного монтирования.

Назначение каждой директории регламентирует «Стандарт иерархии файловой системы» FHS (Filesystem Hierarchy Standard).  
  
[https://gist.github.com/rmnssnvsk/981a2aef08fc008e08bd](https://gist.github.com/rmnssnvsk/981a2aef08fc008e08bd)
#### Команды linux  
`cd, df -h, mv, cp` и тд
`tail -n +2` - вывести содержимое файла с конца начиная со второй строки
`cut -с2-10` - вывести значение со второго по 10-ый символ
`sort -u` - вывести отсортированный список с уникальными значениями
`uniq -c` - вывод уникальных значений с их количеством
`rsync -av tmp1/ tmp2/` - синхронизирует две папки  
#### Директория /proc  
/proc — это директория, к которой примонтирована виртуальная файловая система procfs. Различная информация, которую ядро может сообщить пользователям, находится в "файлах" каталога /proc. Например, в файле /proc/modules находится список загруженных модулей ядра. А в файле /proc/cpuinfo — информация о процессоре компьютера. Подробнее можно прочитать здесь.  
#### Директория /sys  
/sys — это **директория**, к которой примонтирована виртуальная файловая система sysfs, которая добавляет в пространство пользователя информацию ядра Linux о присутствующих в системе устройствах и драйверах.  
#### Состояния процессов:  
**Каждый запущенный процесс в Linux может находиться в одном из следующих состояний:

1.      **Активен (R=Running)** — процесс находится в очереди на выполнение, то есть либо выполняется в данный момент, либо ожидает выделения ему очередного кванта времени центрального процессора.
2.      **«Спит» (S=Sleeping)** — процесс находится в состоянии прерываемого ожидания, то есть ожидает какого-то события, сигнала или освобождения нужного ресурса.
3.      **Находится в состоянии непрерываемого ожидания (D=Direct)** — процесс ожидает определенного («прямого») сигнала от аппаратной части и не реагирует на другие сигналы.
4.      **Приостановлен (T)** — процесс находится в режиме трассировки (обычно такое состояние возникает при отладке программ).
5.    **«Зомби» (Z=Zombie)** — это процесс, выполнение которого завершилось, но относящиеся к нему структуры ядра по каким-то причинам не освобождены.  
#### Как удалить большое количество файлов
`find . -delete или find /mnt/test_dir/ -type f -delete`

`cd /mnt/test_dir/ ; ls -f . | xargs -n 100 rm`  
параметр -f говорит, что не нужно сортировать список файлов

[https://habr.com/ru/articles/157613/](https://habr.com/ru/articles/157613/) 

#### Зомби-процессы
это мертвые и несуществующие процессы, которые занимают место в таблице системных процессов (остатки закрытого программного обеспечения.)  
Такие процессы могут вызвать проблемы.  
#### chown & chmod  
**[https://habr.com/ru/articles/109392/](https://habr.com/ru/articles/109392/)
#### Как** **починить** **chmod -x /bin/chmod?**  
`Python> import os
`Python> os.chmod("/bin/chmod",0755) ` `
#### Что такое Load Average?  
**Load** **Average** - среднее значение загрузки системы за некоторый период времени, как правило, отображается в виде трёх значений, которые представляют собой усредненные величины за последние 1, 5 и 15 минут, **чем ниже значение, тем ниже нагрузка на сервер**. В UNIX это среднее значение вычислительной работы, которую выполняет система. (uptime, top, htop)  
Под средней нагрузкой на сервер понимают суммарную нагрузку процессами на центральный процессор и подсистему ввода/вывода за определённый промежуток времени.  
Максимальным пределом для Load Average обычно считается количество ядер на сервере, которые способны обрабатывать процессы.  
1, 5, 15 - Если первое число больше чем второе и третье, значит нагрузка в данный момент растёт. Если третье число самое большое, второе поменьше, а первое ещё меньше — значит нагрузка на сервере была высокой, но уже упала.  
#### SWAP
один из механизмов виртуальной памяти, при котором отдельные фрагменты памяти (обычно неактивные) перемещаются из ОЗУ во вторичное хранилище (отдельный раздел или файл), освобождая ОЗУ для загрузки других активных фрагментов памяти.
#### Inode
это **структура данных в которой хранится информация о файле или директории в файловой системе**. В файловой системе Linux, например Ext4, у файла есть не только само его содержимое, например, тот текст, но и метаданные, такие как имя, дата создания, доступа, модификации и права. Вот эти метаданные и хранятся в Inode. У каждого файла есть своя уникальная Inode и именно здесь указано в каких блоках находятся данные файла.
#### Типы файловых систем Linux
Список основных файловых систем: **Ext2; Ext3; Ext4; JFS; ReiserFS; XFS; Btrfs; ZFS**. ФС может являться корневой в различных разделах, Linux позволяет использовать разные системы одновременно. Ext2, Ext3, Ext4. Первая группа ФС — Extended Filesystem (Ext2, Ext3, Ext4) — является стандартом для Linux. Как следствие, это самые распространенные системы. Они редко обновляются, но зато стабильны.  
#### Какой сигнал отправится демону/сервису при выполнении команды «systemctl stop daemon_name»?  
Сигнал на остановку службы  
#### Какая команда на GNU/Linux поможет найти файлы, которые менялись в последние полчаса? 
`find . -mmin -30`  
#### Добавить пользователя в группу:  
`sudo groupadd docker` – создать группу “docker”  
`sudo usermod -aG docker $USER` – добавить в группу пользователя (ubuntu)  
#### Дескриптор файла
это целое число без знака, с помощью которого процесс обращается к открытому файлу. stdin, stdout, stderr (0, 1, 2)
#### Как просмотреть открытые приложением файловые дескрипторы?  
В Linux всё является файлами

**lsof** означает ‘LiSt Open Files’ (список открытых файлов). Эта программа используется чтобы узнать, какие файлы открыты и каким процессом.

#### Аутентификация и авторизация  
Простыми словами, аутентификация — это процесс, подтверждающий вашу личность, а авторизация — это процесс, определяющий ваши права после того, как ваша личность подтверждена.  
  
Пример из реальной жизни: когда показываете паспорт на границе, это аутентификация, вы подтверждаете, что вы — Вася Петров. А можно ли вам выезжать из страны? Это уже решает авторизация.  
  
В Linux за аутентификацию отвечают файлы, такие как /etc/passwd (хранит информацию о пользователях) и /etc/shadow (хранит зашифрованные пароли пользователей).  
  
Процесс авторизации наступает после аутентификации и определяет, к каким ресурсам или действиям у вас есть доступ. Разрешено ли вам иметь доступ к определенным разделам сервиса?

Здесь Linux определяет какие у вас есть права доступа с помощью информации из файлов /etc/group — там описаны группы и их члены, и /etc/sudoers — там описано кто может исполнять команды с правами суперпользователя.  
  
Помните: аутентификация всегда предшествует авторизации. Сначала система должна узнать, кто вы, а затем решить, что вы можете делать.  
#### Протоколы аутентификации, авторизации  
Протокол аутентификации — это тип **протокола** компьютерной связи или криптографического **протокола**, специально предназначенного для передачи аутентификационных данных между двумя объектами.  
#### Как заменить в файле строчки другими строчками?  
`sed -i 's/original/new/g' file.txt`  
#### Как распарсить какой-нибудь access.log в Nginx средствами BASH?  
`sudo cat /var/log/nginx/access.log | awk '{ print $1}' | sort | uniq -c | sort` - список IP-адресов пользователей и их количество
#### Симлинк (symlink)  
Символическая ссылка (также «симлинк», от англ. Symbolic link) — специальный файл в файловой системе, в котором вместо пользовательских данных содержится путь к файлу, открываемому при обращении к данной ссылке.**Ln** **— команда Unix, создающая жёсткую ссылку или символьную ссылку на файл.**

Формат команды:

`ln файл имя_ссылки` — создаётся «жёсткая» ссылка (hard link);
`ln -s файл имя_ссылки` — создаётся «символьная» ссылка (symbolic link).

Эта команда создаёт жёсткую ссылку на файл «файл1», которая будет выглядеть и располагаться как «файл2». Таким образом для файловой системы заданный файл «файл1» и ссылка на него «файл2» физически будут являться одним и тем же файлом.

Жёсткая ссылка не может указывать на файл, расположенный на другом дисковом разделе. Также невозможно создать жёсткую ссылку на каталог.
#### Как работает оперативная память компьютера и для чего она нужна
В оперативной памяти в системе Linux хранятся:

- данные ядра;
- данные процессов;
- файлы, которые были прочитаны с жесткого диска или записаны на него.

За выделение оперативной памяти отвечает ядро Linux.

Оперативная память разбивается на страницы по 4KB, а при определённых настройках можно выделить большие страницы (2MB), которые называются HugePages.

Также оперативная память в Linux разбивается на зоны:

— DMA,  
— DMA32,  
— Normal.

Работа с файлами на диске также идёт через оперативную память. Для этого выделяются Cache и Buffer.  
#### Подсистема ввода-вывода  
В Linux ввод и вывод распределяются между тремя стандартными потоками:

- **stdin** — стандартный ввод (клавиатура).
- **stdout** — стандартный вывод (экран).
- **stderr** — стандартная ошибка (вывод ошибок на экран).

Потоки пронумерованы:

- stdin — 0,
- stdout — 1,
- stderr — 2.
  
`ls / &> ls_all` - вывод stdout и strerr в файл ls_all

`ls -l file filefi 2>&1 > /dev/null | grep file` - перенаправление потока ошибок на ввод грепа

`&> или 2>&1` - перенаправление потока вывода и потока ошибок

`ls -l /proc/9/fd` - вывод стандартных потоков процесса с PID'ом 9

Из стандартного ввода команда может только считывать данные, а два других потока могут использоваться только для записи.  
#### Как извлечь данные из лога за определённый период?
`sed -n '/Feb 23 13:55/,/Feb 23 14:00/p' /var/log/mail.log` (пример)  
#### Как в access-логе Nginx посмотреть самые активные IP-адреса за последние сутки с помощью BASH?
[https://jeka.by/post/1067/grep-all-ips/](https://jeka.by/post/1067/grep-all-ips/)  
`less /var/log/nginx/access.log | cut -d' ' -f1 | sort | uniq -c`

#### Bash скриптинг

`#!/bin/bash`

`our comment is here`
`echo "The current directory is:"`
`pwd`
`echo "The user logged in is:"`
`whoami`

[https://habr.com/ru/companies/ruvds/articles/325522/](https://habr.com/ru/companies/ruvds/articles/325522/)

переменная вида $1 - аргумент командой строки, который передан скрипту
#### Что такое буферная и кэш-память в Linux

В более широком смысле, **буфер** – это область памяти, которая временно хранит данные в пути, т.е. данные, которые перемещаются из одной точки в другую. Он содержит метаданные, которые помогают повысить производительность записи.

С другой стороны, **кэш** – это область временного хранения, в которой хранятся часто используемые данные для более быстрого доступа. Когда данные хранятся в кэше, доступ к ним в последующих случаях становится намного быстрее, так как данные извлекаются из кэшированной копии, а не из оригинала.  
#### Очистка системных данных в Linux
- Очистка дискового кэша в Linux  
  `sync; echo 1 > /proc/sys/vm/drop_caches`  
  
- Очистка Dentries & Inodes
  `sync; echo 2 > /proc/sys/vm/drop_caches'`  
  
- Очистка Pagecache, Dentries & Inodes  
  `sync; echo 3 > /proc/sys/vm/drop_caches`  
  
Все вышеприведенные команды разделены на две части с помощью точки с запятой ( ; ), которая появляется между командами sync и echo.

Опция sync очищает буфер файловой системы, а команда echo записывает данные в drop_cache и таким образом очищает кэш, не убивая ни одного приложения/сервиса.

Затем вернемся к запятой, которая инструктирует оболочку выполнить первую команду и после ее выполнения выполнить следующую. Таким образом, в данном случае сначала выполняется команда sync, а затем команда echo.  
#### Как очистить файл подкачки в Linux?

Подкачка swap – это область на жестком диске, которая используется, когда память RAM почти исчерпана или исчерпана. В некоторых ситуациях вам может потребоваться очистить пространство подкачки на вашем компьютере Linux.

Чтобы очистить файл подкачки, просто выполните следующую команду от имени root

`swapoff -a && swapon -a ` 
[https://itshaman.ru/news/linux/kak-opustoshit-bufernuyu-i-kesh-pamyat-v-linux](https://itshaman.ru/news/linux/kak-opustoshit-bufernuyu-i-kesh-pamyat-v-linux)

#### Как сделать так, чтобы команда всегда выполнялась при старте новой сессии bash?
Добавить ее в файл bashrc  
#### Сравнение чисел (bash)
![[сравнение_чисел.png]]  
#### Сравнение строк (bash)  
![[сравнение_строк.png]]
операторы > и < необходимо экранировать  
Пример if [ $val1 \> $val2 ]  
#### Проверка файлов
![[проверка_файлов.png]]

#### Жизненный цикл ПО

- Сбор и анализ требований
- Планирование (Проектирование)
- Разработка
- Тестирование
- Деплой (Развертывание)
- Эксплуатация
#### Типы namespaces в linux  
В Linux существует **семь типов пространств имён (namespaces)**:

1.      Cgroups.
2.      IPC.
3.      Network.
4.      Mount.
5.      PID.
6.      User.
7.      UTS.

Например, **Network namespace** включает в себя системные ресурсы, связанные с сетью, такие как сетевые интерфейсы (например, wlan0, eth0), таблицы маршрутизации и т.д. **Mount namespace** включает файлы и каталоги в системе. **PID namespace** содержит ID процессов и так далее.

Пространства имён (namespaces) предоставляются самим ядром Linux и являются необходимостью для запуска любого процесса в системе.
#### Что будет, если выполнить в консоли из-под root’a chmod a-x $(which chmod) и как это починить?  
- `rsync --chmod=777  
- `python2 -c "import os; os.chmod('/bin/chmod', 0755)" ` 
- `python3 -c "import os; os.chmod('/bin/chmod', 0o755)"`  `
- Стандартная утилита cp умеет перекладывать не только сами файлики, но и переносить отдельно их атрибуты:
	`cp --attributes-only --preserve=mode /bin/chown /bin/chmod  `
- Скопировать с другого сервера

Наверняка, кто-то скажет (и это самый популярный почему-то вариант): скопировать с другой системы. И это можно сделать двумя способами:

- с помощью утилиты scp с флагом -p;
- с помощью утилиты rsync с флагами -av
#### /dev/null
это специальное устройство (файл устройства) в Unix-подобных операционных системах, предназначенное для обнуления данных. Когда данные отправляются в /dev/null, они фактически игнорируются и уничтожаются, а не сохраняются или выводятся куда-либо.

Этот файл устройства часто используется для отбрасывания ненужного вывода программ или для обнуления содержимого файлов, как мы обсуждали ранее. Все данные, направленные в /dev/null, просто исчезают, не занимая никакого места на диске.

/dev/null - это очень полезный инструмент, который позволяет программам выводить данные, но не сохранять их, или создавать файлы с нулевым содержимым, освобождая место на диске.  
#### Использование /dev/null  
1. **Отбрасывание вывода**: Если тебе не нужен вывод какой-либо команды или программы, направь его в /dev/null. Например:

   `ls > /dev/null`

   Это перенаправит вывод команды ls в /dev/null и он просто исчезнет.

2. **Игнорирование сообщений об ошибках**: Если тебе нужно исполнить команду, но ты не хочешь видеть сообщения об ошибках, можно перенаправить stderr в /dev/null:

   `command 2> /dev/null`

3. **Создание пустых файлов**: Можно использовать /dev/null для создания файлов с нулевым содержимым:

   `cat /dev/null > empty_file.txt`

4. **Очистка содержимого файла**: Если тебе нужно обнулить содержимое файла, можно перенаправить /dev/null в этот файл:

   `cat /dev/null > file_to_empty.txt`

Однако помни, что /dev/null уничтожает данные без возможности их восстановления, поэтому будь осторожен при его использовании!
#### Зануление файла с помощью /dev/null  

1. **Зануление файла:**
   Для зануления содержимого файла можно использовать команду cat /dev/null > файл, где файл - это путь к файлу, который нужно занулить.

   Например:
   `cat /dev/null > example.txt`

   Эта команда просто перенаправляет нулевой вывод /dev/null в выбранный файл, что приводит к занулению его содержимого.

2. **Скопировать /dev/null в файл:**
   Также можно скопировать содержимое /dev/null в желаемый файл, используя команду cp /dev/null файл.

   Например:
   `cp /dev/null example.txt`

#### Wildcard-сертификат
это специальный вид SSL-сертификата, который позволяет защитить не только основной домен, но и все его поддомены. Например, если у тебя есть домен example.com, то с помощью wildcard-сертификата ты сможешь защитить также любые поддомены вида subdomain.example.com, blog.example.com и т.д. Это удобно и экономит время, потому что не нужно покупать отдельный сертификат для каждого поддомена.

#### Что такое arp и rarp?

Чтобы выполнять динамическое отображение, были разработаны два протокола: протокол определения адресов (**ARP** – **Address** **Resolution** **Protocol**) и протокол определения сетевого адреса по местоположению (**RARP** – Reserve **Address** **Resolution** **Protocol**). Первый отображает логический адрес в физический адрес, второй отображает физический адрес в логический адрес. **ARP** **и** **RARP** используют однонаправленные и широковещательные физические адреса.