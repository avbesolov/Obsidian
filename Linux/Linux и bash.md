#вопросы_с_собесов #linux #bash
#### Устройство файловой системы Linux  
**Файловая система Linux представляет собой иерархическую структуру каталогов и файлов (в виде дерева).

В Linux файловая система представлена единым корневым каталогом, обозначаемым как слэш (/). Соответственно, при данной файловой структуре не диски содержат каталоги, а каталог — диски.

Основные директории в Linux:

/bin — двоичные исполняемые файлы;
/boot — файлы, используемые для загрузки системы;
/dev — файлы устройств (драйверов);
/etc — файлы конфигураций программ;
/home — домашние каталоги учетных записей пользователей;
/lib — системные библиотеки;
/lost+found — файлы, восстановленные после сбоя работы системы;
/media — точка монтирования внешних носителей;
/mnt — точка временного монтирования.

Назначение каждой директории регламентирует «Стандарт иерархии файловой системы» FHS (Filesystem Hierarchy Standard).  
  
[https://gist.github.com/rmnssnvsk/981a2aef08fc008e08bd](https://gist.github.com/rmnssnvsk/981a2aef08fc008e08bd)
#### Команды linux  
`cd, df -h, mv, cp` и тд
`tail -n +2` - вывести содержимое файла с конца начиная со второй строки
`cut -с2-10` - вывести значение со второго по 10-ый символ
`sort -u` - вывести отсортированный список с уникальными значениями
`uniq -c` - вывод уникальных значений с их количеством
`rsync -av tmp1/ tmp2/` - синхронизирует две папки  
#### Директория /proc  
/proc — это директория, к которой примонтирована виртуальная файловая система procfs. Различная информация, которую ядро может сообщить пользователям, находится в "файлах" каталога /proc. Например, в файле /proc/modules находится список загруженных модулей ядра. А в файле /proc/cpuinfo — информация о процессоре компьютера. Подробнее можно прочитать здесь.  
#### Директория /sys  
/sys — это **директория**, к которой примонтирована виртуальная файловая система sysfs, которая добавляет в пространство пользователя информацию ядра Linux о присутствующих в системе устройствах и драйверах.  
#### Состояния процессов:  
**Каждый запущенный процесс в Linux может находиться в одном из следующих состояний:

1.      **Активен (R=Running)** — процесс находится в очереди на выполнение, то есть либо выполняется в данный момент, либо ожидает выделения ему очередного кванта времени центрального процессора.
2.      **«Спит» (S=Sleeping)** — процесс находится в состоянии прерываемого ожидания, то есть ожидает какого-то события, сигнала или освобождения нужного ресурса.
3.      **Находится в состоянии непрерываемого ожидания (D=Direct)** — процесс ожидает определенного («прямого») сигнала от аппаратной части и не реагирует на другие сигналы.
4.      **Приостановлен (T)** — процесс находится в режиме трассировки (обычно такое состояние возникает при отладке программ).
5.    **«Зомби» (Z=Zombie)** — это процесс, выполнение которого завершилось, но относящиеся к нему структуры ядра по каким-то причинам не освобождены.  
#### Как удалить большое количество файлов
`find . -delete или find /mnt/test_dir/ -type f -delete`

`cd /mnt/test_dir/ ; ls -f . | xargs -n 100 rm`  
параметр -f говорит, что не нужно сортировать список файлов

[https://habr.com/ru/articles/157613/](https://habr.com/ru/articles/157613/) 
#### top (значения)
В команде **top** в Linux есть информация об использовании CPU.

Вот некоторые значения, которые она показывает:

**us** — потребление CPU пользовательскими процессами;
**sy** — потребление CPU системными процессами;
**ni** — потребление CPU пользовательскими процессами с изменённым приоритетом (командой nice или renice);
**id** — простаивание CPU (от idle — работать вхолостую);
**wa** — процент времени, в течение которого процессор простаивал, ожидая завершения операции ввода-вывода;
**hi** — процент времени работы аппаратных прерываний;
**si** — процент времени работы программных прерываний;
**st** — процент времени, когда реальный процессор не был доступен виртуальной машине.  
#### Зомби-процессы
это мертвые и несуществующие процессы, которые занимают место в таблице системных процессов (остатки закрытого программного обеспечения.)  
Такие процессы могут вызвать проблемы.  
#### chown & chmod  
**[https://habr.com/ru/articles/109392/](https://habr.com/ru/articles/109392/)
#### Как** **починить** **chmod -x /bin/chmod?**  
`Python> import os
Python> os.chmod("/bin/chmod",0755)  `
#### Что такое Load Average?  
**Load** **Average** - среднее значение загрузки системы за некоторый период времени, как правило, отображается в виде трёх значений, которые представляют собой усредненные величины за последние 1, 5 и 15 минут, **чем ниже значение, тем ниже нагрузка на сервер**. В UNIX это среднее значение вычислительной работы, которую выполняет система. (uptime, top, htop)  
Под средней нагрузкой на сервер понимают суммарную нагрузку процессами на центральный процессор и подсистему ввода/вывода за определённый промежуток времени.  
Максимальным пределом для Load Average обычно считается количество ядер на сервере, которые способны обрабатывать процессы.  
1, 5, 15 - Если первое число больше чем второе и третье, значит нагрузка в данный момент растёт. Если третье число самое большое, второе поменьше, а первое ещё меньше — значит нагрузка на сервере была высокой, но уже упала.  
#### SWAP
один из механизмов виртуальной памяти, при котором отдельные фрагменты памяти (обычно неактивные) перемещаются из ОЗУ во вторичное хранилище (отдельный раздел или файл), освобождая ОЗУ для загрузки других активных фрагментов памяти.
#### Inode
это **структура данных в которой хранится информация о файле или директории в файловой системе**. В файловой системе Linux, например Ext4, у файла есть не только само его содержимое, например, тот текст, но и метаданные, такие как имя, дата создания, доступа, модификации и права. Вот эти метаданные и хранятся в Inode. У каждого файла есть своя уникальная Inode и именно здесь указано в каких блоках находятся данные файла.
#### Типы файловых систем Linux
Список основных файловых систем: **Ext2; Ext3; Ext4; JFS; ReiserFS; XFS; Btrfs; ZFS**. ФС может являться корневой в различных разделах, Linux позволяет использовать разные системы одновременно. Ext2, Ext3, Ext4. Первая группа ФС — Extended Filesystem (Ext2, Ext3, Ext4) — является стандартом для Linux. Как следствие, это самые распространенные системы. Они редко обновляются, но зато стабильны.  
#### Какой сигнал отправится демону/сервису при выполнении команды «systemctl stop daemon_name»?  
Сигнал на остановку службы  
#### Какая команда на GNU/Linux поможет найти файлы, которые менялись в последние полчаса? 
`find . -mmin -30`  
#### Добавить пользователя в группу:  
`sudo groupadd docker` – создать группу “docker”  
`sudo usermod -aG docker $USER` – добавить в группу пользователя (ubuntu)  
#### Дескриптор файла
это целое число без знака, с помощью которого процесс обращается к открытому файлу. stdin, stdout, stderr (0, 1, 2)
#### Как просмотреть открытые приложением файловые дескрипторы?  
В Linux всё является файлами

**lsof** означает ‘LiSt Open Files’ (список открытых файлов). Эта программа используется чтобы узнать, какие файлы открыты и каким процессом.
#### lsof
Утилита `lsof` - это невероятно полезная команда, которая выводит список всех открытых файлов (LiSts all Open Files).

Утилита `lsof` по умолчанию выводит следующую информацию о каждом файле:

- `COMMAND` — название процесса или команды, которая использует файл;
- `PID` — идентификатор процесса;
- `USER` — пользователь, которому принадлежит процесс;
- `FD` — дескриптор файла (например, `cwd` — текущий рабочий каталог, `txt` — исполняемый код, `mem` — отображенные в память файлов, `rtd` — корневой каталог);
- `TYPE` — тип файла или объекта файловой системы (например, `REG` — обычный файл, `DIR` — каталог, и другие);
- `DEVICE` — мажорный и минорный номера устройства, на котором находится файл;
- `SIZE/OFF` — размер файла или значение смещения в нем;
- `NODE` — номер индексного дескриптора (`inode`);
- `NAME` — абсолютный путь к файлу.

`lsof -u user` - отображение файлов, используемых конкретным пользователем
`lsof -u ^user` - исключить файлы опред. пользователя
`lsof -i` - Поиск процессов, которые прослушивают сетевые порты
`lsof -i -u user` - информация о файлах, открытых процессами конкретного пользователя, использующих сетевые соединения
`lsof -i TCP:22` - Просмотр процессов, работающих на сетевых портах определенного диапазона
`lsof -p 1` - Вывод списка файлов, используемых определенным процессом
`lsof -t -u user` - вывести на экран идентификаторы процессов запущенных конкретным пользователем
`kill -9 $(lsof -t -u user)` - завершить процессы конкретного пользователя

https://blog.sedicomm.com/2020/03/19/10-primerov-komand-lsof-v-linux/ - 10 примеров использования команды lsof в Linux
https://reference-xi.vercel.app/lsof.html - lsof cheatsheet

#### Аутентификация и авторизация  
Простыми словами, аутентификация — это процесс, подтверждающий вашу личность, а авторизация — это процесс, определяющий ваши права после того, как ваша личность подтверждена.  
  
Пример из реальной жизни: когда показываете паспорт на границе, это аутентификация, вы подтверждаете, что вы — Вася Петров. А можно ли вам выезжать из страны? Это уже решает авторизация.  
  
В Linux за аутентификацию отвечают файлы, такие как /etc/passwd (хранит информацию о пользователях) и /etc/shadow (хранит зашифрованные пароли пользователей).  
  
Процесс авторизации наступает после аутентификации и определяет, к каким ресурсам или действиям у вас есть доступ. Разрешено ли вам иметь доступ к определенным разделам сервиса?

Здесь Linux определяет какие у вас есть права доступа с помощью информации из файлов /etc/group — там описаны группы и их члены, и /etc/sudoers — там описано кто может исполнять команды с правами суперпользователя.  
  
Помните: аутентификация всегда предшествует авторизации. Сначала система должна узнать, кто вы, а затем решить, что вы можете делать.  
#### Протоколы аутентификации, авторизации  
Протокол аутентификации — это тип **протокола** компьютерной связи или криптографического **протокола**, специально предназначенного для передачи аутентификационных данных между двумя объектами.  
#### Как заменить в файле строчки другими строчками?  
`sed -i 's/original/new/g' file.txt`  
#### Как распарсить какой-нибудь access.log в Nginx средствами BASH?  
`sudo cat /var/log/nginx/access.log | awk '{ print $1}' | sort | uniq -c | sort` - список IP-адресов пользователей и их количество
#### Симлинк (symlink)  
Символическая ссылка (также «симлинк», от англ. Symbolic link) — специальный файл в файловой системе, в котором вместо пользовательских данных содержится путь к файлу, открываемому при обращении к данной ссылке.**Ln** **— команда Unix, создающая жёсткую ссылку или символьную ссылку на файл.**

Формат команды:

`ln файл имя_ссылки` — создаётся «жёсткая» ссылка (hard link);
`ln -s файл имя_ссылки` — создаётся «символьная» ссылка (symbolic link).

Эта команда создаёт жёсткую ссылку на файл «файл1», которая будет выглядеть и располагаться как «файл2». Таким образом для файловой системы заданный файл «файл1» и ссылка на него «файл2» физически будут являться одним и тем же файлом.

Жёсткая ссылка не может указывать на файл, расположенный на другом дисковом разделе. Также невозможно создать жёсткую ссылку на каталог.
#### Как работает оперативная память компьютера и для чего она нужна
В оперативной памяти в системе Linux хранятся:

- данные ядра;
- данные процессов;
- файлы, которые были прочитаны с жесткого диска или записаны на него.

За выделение оперативной памяти отвечает ядро Linux.

Оперативная память разбивается на страницы по 4KB, а при определённых настройках можно выделить большие страницы (2MB), которые называются HugePages.

Также оперативная память в Linux разбивается на зоны:

— DMA,  
— DMA32,  
— Normal.

Работа с файлами на диске также идёт через оперативную память. Для этого выделяются Cache и Buffer.  
#### Подсистема ввода-вывода  
В Linux ввод и вывод распределяются между тремя стандартными потоками:

- **stdin** — стандартный ввод (клавиатура).
- **stdout** — стандартный вывод (экран).
- **stderr** — стандартная ошибка (вывод ошибок на экран).

Потоки пронумерованы:

- stdin — 0,
- stdout — 1,
- stderr — 2.
  
`ls / &> ls_all` - вывод stdout и strerr в файл ls_all

`ls -l file filefi 2>&1 > /dev/null | grep file` - перенаправление потока ошибок на ввод грепа

`&> или 2>&1` - перенаправление потока вывода и потока ошибок

`ls -l /proc/9/fd` - вывод стандартных потоков процесса с PID'ом 9

Из стандартного ввода команда может только считывать данные, а два других потока могут использоваться только для записи.  
#### Как извлечь данные из лога за определённый период?
`sed -n '/Feb 23 13:55/,/Feb 23 14:00/p' /var/log/mail.log` (пример)  
#### Как в access-логе Nginx посмотреть самые активные IP-адреса за последние сутки с помощью BASH?
[https://jeka.by/post/1067/grep-all-ips/](https://jeka.by/post/1067/grep-all-ips/)  
`less /var/log/nginx/access.log | cut -d' ' -f1 | sort | uniq -c`
#### mount
[https://losst.pro/montirovanie-diska-v-linux](https://losst.pro/montirovanie-diska-v-linux)_  
добавление диска (устройства) в автозагрузки системы  
`sudo fdisk -l`  
Ищем наш раздел, запоминаем его название. Например, /dev/sda2.  
Теперь создаем директорию /mnt/D.  
`sudo mkdir -p /mnt/D`  
Затем редактируем файл /etc/fstab, чтобы диск монтировался при загрузке.  
Добавляем строчку:  
`/dev/sda2        /mnt/D        ntfs-3g        ro        1 1`  
Где:  
/dev/sda2 - монтируемый раздел  
/mnt/D - точка монтирования  
ntfs-3g - файловая система  
ro - для монтирования в режиме только для чтения. Если нужно писать на раздел, замени на defaults  
Теперь при загрузке ОС раздел /dev/sda2 будет монтироваться в /mnt/D.  
#### fstab
Fstab (сокр. от англ. file systems table) — один из конфигурационных файлов в UNIX-подобных системах, который содержит информацию о различных файловых системах и устройствах хранения информации компьютера.

Он описывает, как диск (раздел) будет использоваться или как будет интегрирован в систему.

Полный путь к файлу — /etc/fstab.
#### fdisk
[https://losst.pro/komanda-fdisk-v-linux](https://losst.pro/komanda-fdisk-v-linux)  
Команда fdisk (format disk, форматировать диск) — это наиболее распространенная утилита командной строки для работы с дисками в Linux. Позволяет просматривать, создавать, удалять, изменять, копировать и перемещать разделы на жестком диске, используя простой интерфейс текстовых меню.
#### Bash скриптинг

`#!/bin/bash`

`our comment is here`
`echo "The current directory is:"`
`pwd`
`echo "The user logged in is:"`
`whoami`

[https://habr.com/ru/companies/ruvds/articles/325522/](https://habr.com/ru/companies/ruvds/articles/325522/)

переменная вида $1 - аргумент командой строки, который передан скрипту
#### Что такое буферная и кэш-память в Linux

В более широком смысле, **буфер** – это область памяти, которая временно хранит данные в пути, т.е. данные, которые перемещаются из одной точки в другую. Он содержит метаданные, которые помогают повысить производительность записи.

С другой стороны, **кэш** – это область временного хранения, в которой хранятся часто используемые данные для более быстрого доступа. Когда данные хранятся в кэше, доступ к ним в последующих случаях становится намного быстрее, так как данные извлекаются из кэшированной копии, а не из оригинала.  
#### Очистка системных данных в Linux
- Очистка дискового кэша в Linux  
  `sync; echo 1 > /proc/sys/vm/drop_caches`  
  
- Очистка Dentries & Inodes
  `sync; echo 2 > /proc/sys/vm/drop_caches'`  
  
- Очистка Pagecache, Dentries & Inodes  
  `sync; echo 3 > /proc/sys/vm/drop_caches`  
  
Все вышеприведенные команды разделены на две части с помощью точки с запятой ( ; ), которая появляется между командами sync и echo.

Опция sync очищает буфер файловой системы, а команда echo записывает данные в drop_cache и таким образом очищает кэш, не убивая ни одного приложения/сервиса.

Затем вернемся к запятой, которая инструктирует оболочку выполнить первую команду и после ее выполнения выполнить следующую. Таким образом, в данном случае сначала выполняется команда sync, а затем команда echo.  
#### Как очистить файл подкачки в Linux?

Подкачка swap – это область на жестком диске, которая используется, когда память RAM почти исчерпана или исчерпана. В некоторых ситуациях вам может потребоваться очистить пространство подкачки на вашем компьютере Linux.

Чтобы очистить файл подкачки, просто выполните следующую команду от имени root

`swapoff -a && swapon -a ` 
[https://itshaman.ru/news/linux/kak-opustoshit-bufernuyu-i-kesh-pamyat-v-linux](https://itshaman.ru/news/linux/kak-opustoshit-bufernuyu-i-kesh-pamyat-v-linux)
#### Logical Volume Manager (LVM)
это очень мощная система управления томами с данными для Linux. Она позволяет создавать поверх физических разделов (или даже неразбитых винчестеров) логические тома, которые в самой системе будут видны как обычные блочные устройства с данными (т.е. как обычные разделы).  
[https://help.ubuntu.ru/wiki/lvm](https://help.ubuntu.ru/wiki/lvm)  
#### Как сделать так, чтобы команда всегда выполнялась при старте новой сессии bash?
Добавить ее в файл bashrc  
#### Сравнение чисел (bash)
![[сравнение_чисел.png]]  
#### Сравнение строк (bash)  
![[сравнение_строк.png]]
операторы > и < необходимо экранировать  
Пример if [ $val1 \> $val2 ]  
#### Проверка файлов
![[проверка_файлов.png]]
#### Systemd
это **программный пакет, который предоставляет множество системных компонентов для операционных систем Linux**. Основная цель - унифицировать конфигурацию и поведение сервиса во всех дистрибутивах Linux. Его основным компонентом является "system and service manager" – система инициализации, используемая для начальной загрузки пользовательского пространства и управления пользовательскими процессами.

Подсистема инициализации и управления службами в Linux[https://habr.com/ru/companies/slurm/articles/255845/](https://habr.com/ru/companies/slurm/articles/255845/)

Вот некоторые основные команды systemd:
1. **systemctl start name.service** — запуск сервиса.
2. **systemctl stop name.service** — остановка сервиса.
3. **systemctl restart name.service** — перезапуск сервиса.
4. **systemctl try-restart name.service** — перезапуск сервиса только, если он запущен.
5. **systemctl reload name.service** — перезагрузка конфигурации сервиса.
6. **systemctl status name.service** — проверка, запущен ли сервис с детальным выводом состояния сервиса.
7. **systemctl is-active name.service** — проверка, запущен ли сервис с простым ответом: active или inactive.
8. **systemctl list-units --type service --all** — отображение статуса всех сервисов.
9. **systemctl enable name.service** — активирует сервис (позволяет стартовать во время запуска системы).
10. **systemctl disable name.service** — деактивирует сервис.

#### Жизненный цикл ПО

- Сбор и анализ требований
- Планирование (Проектирование)
- Разработка
- Тестирование
- Деплой (Развертывание)
- Эксплуатация
#### Типы namespaces в linux  
В Linux существует **семь типов пространств имён (namespaces)**:

1.      Cgroups.
2.      IPC.
3.      Network.
4.      Mount.
5.      PID.
6.      User.
7.      UTS.

Например, **Network namespace** включает в себя системные ресурсы, связанные с сетью, такие как сетевые интерфейсы (например, wlan0, eth0), таблицы маршрутизации и т.д. **Mount namespace** включает файлы и каталоги в системе. **PID namespace** содержит ID процессов и так далее.

Пространства имён (namespaces) предоставляются самим ядром Linux и являются необходимостью для запуска любого процесса в системе.
#### Что будет, если выполнить в консоли из-под root’a chmod a-x $(which chmod) и как это починить?  
- `rsync --chmod=777  
- `python2 -c "import os; os.chmod('/bin/chmod', 0755)" ` 
- `python3 -c "import os; os.chmod('/bin/chmod', 0o755)"`  `
- Стандартная утилита cp умеет перекладывать не только сами файлики, но и переносить отдельно их атрибуты:
	`cp --attributes-only --preserve=mode /bin/chown /bin/chmod  `
- Скопировать с другого сервера

Наверняка, кто-то скажет (и это самый популярный почему-то вариант): скопировать с другой системы. И это можно сделать двумя способами:

- с помощью утилиты scp с флагом -p;
- с помощью утилиты rsync с флагами -av
#### /dev/null
это специальное устройство (файл устройства) в Unix-подобных операционных системах, предназначенное для обнуления данных. Когда данные отправляются в /dev/null, они фактически игнорируются и уничтожаются, а не сохраняются или выводятся куда-либо.

Этот файл устройства часто используется для отбрасывания ненужного вывода программ или для обнуления содержимого файлов, как мы обсуждали ранее. Все данные, направленные в /dev/null, просто исчезают, не занимая никакого места на диске.

/dev/null - это очень полезный инструмент, который позволяет программам выводить данные, но не сохранять их, или создавать файлы с нулевым содержимым, освобождая место на диске.  
#### Использование /dev/null  
1. **Отбрасывание вывода**: Если тебе не нужен вывод какой-либо команды или программы, направь его в /dev/null. Например:

   `ls > /dev/null`

   Это перенаправит вывод команды ls в /dev/null и он просто исчезнет.

2. **Игнорирование сообщений об ошибках**: Если тебе нужно исполнить команду, но ты не хочешь видеть сообщения об ошибках, можно перенаправить stderr в /dev/null:

   `command 2> /dev/null`

3. **Создание пустых файлов**: Можно использовать /dev/null для создания файлов с нулевым содержимым:

   `cat /dev/null > empty_file.txt`

4. **Очистка содержимого файла**: Если тебе нужно обнулить содержимое файла, можно перенаправить /dev/null в этот файл:

   `cat /dev/null > file_to_empty.txt`

Однако помни, что /dev/null уничтожает данные без возможности их восстановления, поэтому будь осторожен при его использовании!
#### Зануление файла с помощью /dev/null  

1. **Зануление файла:**
   Для зануления содержимого файла можно использовать команду cat /dev/null > файл, где файл - это путь к файлу, который нужно занулить.

   Например:
   `cat /dev/null > example.txt`

   Эта команда просто перенаправляет нулевой вывод /dev/null в выбранный файл, что приводит к занулению его содержимого.

2. **Скопировать /dev/null в файл:**
   Также можно скопировать содержимое /dev/null в желаемый файл, используя команду cp /dev/null файл.

   Например:
   `cp /dev/null example.txt`
#### rpm - менеджер пакетов
(рекурсивный акроним RPM Package Manager — RPM — менеджер пакетов) — **формат пакетов программного обеспечения, а также программа, созданная для управления этими пакетами, используемые в ряде Linux-дистрибутивов.** Является основным форматом пакетов в LSB.

Изначально разработанный компанией Red Hat для Red Hat Linux, RPM стал использоваться во многих дистрибутивах Linux и был портирован на другие операционные системы: Novell NetWare (с версии 6.5 SP3), IBM AIX (с версии 5) и прочие.

https://churchill.ddns.me.uk/post/rpm-cheat-sheet/ - cheatsheet
#### yum - менеджер пакетов
(Yellowdog Updater, Modified) — открытый консольный менеджер пакетов для дистрибутивов Linux, основанных на пакетах формата RPM** (RedHat, CentOS, Fedora, Oracle Linux).

Он позволяет облегчить работу с обновлениями дистрибутивов, отслеживая взаимозависимости между пакетами.

**Возможности YUM:**

- поиск пакетов в репозиториях;
- установка пакетов из репозиториев;
- установка пакетов из .rpm-файлов с удовлетворением зависимостей с помощью репозиториев;
- обновление системы;
- удаление ненужных пакетов;
- даунрейд пакетов.

https://habr.com/ru/articles/301292/ - шпаргалка
#### Cron
утилита для планирования задач в операционной системе Linux. Она позволяет запускать скрипты или команды автоматически в определенное время, с определенной периодичностью или при определенных событиях.

https://devhints.io/cron - cron cheatsheet
#### Logrotate
это системная утилита, которая управляет автоматической ротацией и сжатием лог-файлов. Если в процессе длительной работы сервера файлы не были ротированы, сжаты и периодически не удалялись, то рано или поздно они могут занять весь доступный объем памяти.

https://losst.pro/nastrojka-logrotate - Настройка Logrotate
https://www.jamescoyle.net/cheat-sheets/676-logrotate-cheat-sheet - logrotate cheatsheet
#### iptables 
это инструмент командной строки, который используется для настройки и управления брандмауэром ядра Linux.

Он позволяет создавать правила, которые определяют, как обрабатывается входящий и исходящий трафик. Его можно использовать для блокировки или разрешения трафика на основе IP-адреса, номера порта, протокола и других критериев.

https://www.youtube.com/watch?v=wHUYOX_pUek&t=2094s - полезный видос
https://andreafortuna.org/2019/05/08/iptables-a-simple-cheatsheet/ - iptables cheatsheet
#### ss 
консольная **утилита**, которая предоставляет информацию о сетевых сокетах, подключениях TCP/UDP, маршрутизации и других сетевых статистических данных. 
**ss** отображает информацию аналогично **утилите** netstat и при этом выводит больше информации о сетевых соединениях и их состоянии, чем какие-либо другие инструменты

*Пример использования*
`ss -tulpn`
- -t: Показывает только TCP-соединения.
- -u: Показывает только UDP-соединения.
- -l: Показывает только слушающие порты.
- -p: Показывает идентификаторы процессов (PID), связанные с сокетами.
- -n: Показывает числовой формат IP-адресов и портов вместо их имен.

https://www.golinuxcloud.com/ss-command-in-linux/ - cheatsheet
#### atop
это продвинутый интерактивный полноэкранный монитор производительности.
Он является аналогом top, но в отличие от него выводит только новые изменения об активных системных процессах.
Важной особенностью является возможность сохранения данных в файл собственного двоичного формата.

**Основные параметры**
- Строка **PRC** – отображает общие данные на уровне процессов и потоков:
    - sys, user – общее время процессора, затраченное в системном режиме и в пользовательском режиме соответственно; 
    - proc – общее количество процессов, активных в системе на текущий момент;
    - trun – общее количество потоков, активных в данный момент;
    - tslpi – общее количество потоков, которые сейчас находятся в спящем режиме и могут быть прерваны;
    - tslpu – общее количество потоков, которые в текущее время находятся в спящем режиме и не могут быть прерваны;
    - zombie – количество процессов-зомби;
    - clones – количество системных вызовов клонов для процессов;
    - exit – количество процессов, завершившихся за прошедшее время.
- Строка **CPU** – выводит общие данные о нагрузке на центральный процессор. Верхняя строка показывает общую занятость для всего процессора. В случае многоядерной системы для каждого отдельного ядра отображается дополнительные строки с «cpu» в нижнем регистре, отсортированные по активности. Для каждого ядра и всего процессора содержатся следующие показатели:
    - sys, user – общее время процессора, затраченное в системном режиме и в пользовательском режиме соответственно;
    - irq – процент времени процессора, затраченного на обработку прерываний;
    - idle – процент неиспользованного времени процессора, когда ни один из процессов не ожидает дискового ввода-вывода;
    - wait – процент неиспользованного времени процессора, пока по крайней мере один процесс ждал дисковый ввод-вывод;
- Строка **CPL** – показывает  LA (Load Average) за 1, 5 и 15 минут, а также количество доступных ядер процессора.
- Строка **MEM** – показывает общую информацию об оперативной памяти:
    - tot – общий объем доступной оперативной памяти;
    - free – общий объем свободной памяти;
    - cache – текущий объем кэш-памяти;
    - dirty – объем памяти в страничном кэше, который необходимо сбросить на диск;
    - buff  – объем памяти, используемый для метаданных файловой системы;
- Строка **Swap** – показывает общую информацию о swap.
- Строка **DSK** — показывает использование диска:
    - busy – процент времени, в течение которого система занята обработкой запросов;
    - read – выданные запросы на чтение;
    - write – выданные запросы на запись;
    - KiB/r и KiB/w – скорость чтения и записи данных (в КB) на каждый запрос;
    - MBr/s и MBw/s – временные показатели для чтения и записи на диск в мегабайтах.
    - avio – среднее количество миллисекунд, затраченных на обработку запросов.
- Строки **NET** – показывают общую статистику использованию сети на транспортном и сетевом уровне, а также отдельно по каждому активному сетевому интерфейсу.
  
-----

**Во время работы программы можно применять следующие горячие клавиши для изменения нижней части окна:**

- **для изменения отображения таблицы процессов — отвечает за просмотр:**

        'm' - памяти, используемой процессами;
        'd'  - использования диска процессами;
        'n'  - использования сети;
        'v'  - детальной информации по  процессам (ppid, user/group, date/time, status, exitcode)
        'c'  - полной команды для каждого процесса.

- **для сортировки по использованию:**

        'C'  - процессора;
        'M' - оперативной памяти;
        'D'  - оперативной дисковой системы;
        'N'  - оперативной дисковой сети;
        'A'  -  самые активные пользователи ресурсов (auto mode).

- **для суммирования:**

        'u'  - по пользователям системы;
        'p'  - по процессам.

 - **для поиска* — фокус на определённом:**

        'U'  - пользователе системы;
        'P'  - процессе по названию;
        'I'  - процессе по PID;
        '/'  - выражении командной строки или её части.
        
-----

**Общий вывод команды `atop` отображает следующие сведения для каждой записи процесса:**

- PID – идентификатор процесса.
- SYSCPU — объем ЦП, потребляемый процессом при работе системы.
- USRCPU – количество ЦП, потребляемое процессом во время его работы в пользовательском режиме.
- VGROW – объем виртуальной памяти, которую процесс занял с момента последнего обновления значения.
- RGROW — объем резидентной (физической) памяти, увеличенный с момента последнего обновления значения.
- RDDSK — размер данных, передаваемых во время чтения с диска.
- WRDSK — размер данных, передаваемых во время записи на диск.
- RUID – реальный идентификатор пользователя, под которым выполняется процесс.
- EUID — эффективный идентификатор пользователя, под которым выполняется процесс.
- ST – текущий статус процесса.
- EXC – код выхода после завершения процесса.
- THR — количество потоков в процессе.
- S – текущий статус основного потока процесса.
- ЦП – процент использования ЦП для всего процесса.
- CMD — имя процесса.

**Потребление памяти**
`atop -m`

- PID – идентификатор процесса.
- TID – идентификатор потока.
- MINFLT – количество незначительных ошибок страниц, которые были устранены путем доступа к данным с бесплатных страниц.
- MAJFLT – количество серьезных ошибок страниц, которые были устранены путем извлечения данных с диска.
- VSTEXT — виртуальная память, занятая текстом процесса.
- VSLIBS – виртуальная память, занимаемая общими библиотеками процесса.
- VDATA — размер виртуальной памяти для частных данных процесса.
- VSTACK — размер виртуальной памяти частного стека процесса.
- VSIZE — общий размер виртуальной памяти процесса.
- RSIZE — общая резидентная память, занятая процессом.
- MEM — процент оперативной памяти, потребляемой процессом.

**Использование диска**
`atop -d`

В выводе, специфичном для диска, не так много вещей, на которые можно обратить внимание. Вот некоторые из ключевых выводов:

- RDDSK — размер данных, передаваемых во время чтения с диска.
- WRDSK — размер данных, передаваемых во время записи на диск.
- WCANCL — размер данных, изначально записанных, но позже удаленных.
- DSK – процент занятого места на диске.
- CMD — имя процесса.

**Еще команды**
`atop -c` - просмотреть процессы работающие в фоновом режиме
`atop -y` - информация по потокам
`atop -v` - подробнее о процессе
`atop -au` - количество процессов для каждого пользователя в системе
`atop -s` - на каком ядре работает процесс

https://firstvds.ru/technology/statistika-nagruzki-na-server-atop - работа с atop
#### atopsar
Команда atopsar — это встроенный анализатор логов atop, который позволит быстро найти проблему и смотреть лог в нужное вам время.

**Общая структура команды:**
`atopsar [-flags] [-r file|date|y...] [-R cnt] [-b hh:mm] [-e hh:mm]`

Все логи сохраняются в каталоге по пути **/var/log/atop/**, файлы именуются по формату `atop_<дата>`.

Основные ключи:

- **-r** — считывание данных из файла;
- **-b** — с какого времени вывести лог;
- **-e** — до какого времени вывести лог.

Дополнительные опции для анализа:

- **-d** — нагрузка на каждый диск;
- **-m** — нагрузка на оперативную память и **swap**;
- **-с** — нагрузка на процессор, отдельно по каждому ядру;
- **-p** — количество процессов и потоков;
- **-w** — нагрузка на сетевой трафик;
- **-i** — нагрузка на интерфейс;
- **-O** — топ-3 процессов по использованию процессора;
- **-G** — топ-3 процессов по использованию памяти;
- **-D** — топ-3 процессов по использованию диска;
- **-N** — топ-3 процессов по использованию сети;
- **-A** — все возможные отчеты.

Например, можно смотреть нагрузку на диск по анализу логов за определенный день и время, используя ключ **-d**:  

`atopsar -r /var/log/atop/atop_20231130 -d -b 14:00 -e 16:00`

https://redos.red-soft.ru/base/manual/utilites/atopsar/ - работа с atopsar
#### ncdu
Утилита `ncdu` — один из самых удобных инструментов для анализа дискового пространства. Она имеет псевдографический интерфейс, что значительно упрощает работу с ней.

`ncdu имя_каталога` - просканировать и вывести данные о конкретной директории:

**Формат вывода**

Количество символов `#` помогает определить, какие файлы и каталоги занимают больше всего места.

Крайний левый столбец может содержать дополнительные обозначения:

- `!` — ошибка при чтении каталога;
- `.` — ошибка при чтении подкаталога, т.е. указанный размер может быть некорректным;
- `<` — объект исключен из подсчета (с помощью опции `--exclude`);
- `>` — объект из другой файловой системы;
- `@` — объект не является файлом или каталогом (символическая ссылка, сокет);
- `H` — объект уже был учтен (жесткая ссылка);
- `e` — пустой каталог.
  
**Доступные функции интерфейса**

С помощью следующих клавиш можно управлять полученным выводом:

- `n` — упорядочить элементы по имени (в прямом и обратном порядке);
- `s` — упорядочить элементы по размеру (в прямом и обратном порядке);
- `g` — переключение между отображением «графика» (####) и объёма в процентах;
- `a` — переключение между отображением реального размера файлов и объемом занимаемого пространства на диске;
- `e` — скрыть/показать скрытые файлы и папки;
- `?` — вызвать краткую справку;
- `d` — удалить выбранный элемент (перед удалением будет запрошено подтверждение действия);
- `i` — вывести информацию о выбранном элементе
- `q` — выйти.

https://timeweb.cloud/docs/unix-guides/troubleshooting-unix/disk-space-analysis-ncdu-du 
#### du
утилита позволяет получить общую информацию о занятом месте

При выполнении команды она выводит объем пространства, занимаемого каждым файлом и каталогом в текущем каталоге:

`du -shc /*` - выведет итоговый размер указанной директории в человекочитаемом виде с общим размером занятого пространства

`du -sch ./* | sort -hr` - Полезный и удобный способ подсчета и сортировки

https://timeweb.cloud/docs/unix-guides/troubleshooting-unix/disk-space-analysis-ncdu-du 

